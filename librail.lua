--
-- Created by IntelliJ IDEA.
-- User: Daniel
-- Date: 10/26/2018
-- Time: 10:45 AM
-- To change this template use File | Settings | File Templates.
--
require('util')


local sqrt2 = 1.5  -- math.sqrt(2)


-- Defines we use a lot, so abbreviate and reference them.
local rd = defines.rail_direction
local rcd = defines.rail_connection_direction
local dir = defines.direction

--
-- Private functions/tables
--


-- We supply offsets for north and northeast facings only.  All others are generated by calculating rotations, using
-- this table.
local _rotations = {
    {dir.north, dir.east},
    {dir.northeast, dir.southeast},
    {dir.east, dir.south},
    {dir.southeast, dir.southwest},
    {dir.south, dir.west},
    {dir.southwest, dir.northwest},
}

local function each_rotation()
    local i = 0
    local t
    return function()
        i = i + 1
        if _rotations[i] then return unpack(_rotations[i]) end
        return nil
    end
end


-- Performs a 90 degree rotation of src
local function rotate_cw(src) return { x=-src.y, y=src.x, d=src.d and (src.d+2)%8 or nil } end


-- Given bounds and a position, extend the bounds to fit the position.
local function expand_bounds(bounds, position)
    if not bounds then
        bounds = { left_top = { x = position.x, y=position.y }, right_bottom = {x=position.x, y=position.y} }
    else
        if position.x < bounds.left_top.x then bounds.left_top.x = position.x
        elseif position.x > bounds.right_bottom.x then bounds.right_bottom.x = position.x
        end

        if position.y < bounds.left_top.y then bounds.left_top.y = position.y
        elseif position.y > bounds.right_bottom.y then bounds.right_bottom.y = position.y
        end
    end
    return bounds
end


-- Offset bounds by the specified offset.
local function offset_bounds(bounds, offset, t)
    if not t then t = {left_top = {}, right_bottom={} } end
    t.left_top.x = bounds.left_top.x + offset.x
    t.left_top.y = bounds.left_top.y + offset.y
    t.right_bottom.x = bounds.right_bottom.x + offset.x
    t.right_bottom.y = bounds.right_bottom.y + offset.y
    return t
end


local librail = {
    -- rail_connection_direction defines a 'none, which is useless and causes errors with get_connected_rail.
    -- Add our own to deal with this.
    rail_connection_directions = { rcd.left, rcd.straight, rcd.right },
    rail_directions = { rd.front, rd.back },

    rail_entity_types = {"straight-rail", "curved-rail" },
    signal_entity_types = {"rail-signal", "rail-chain-signal"},

    -- Use: chiral_directions[source.chirality == dest.chirality][direction]
    chiral_directions = {
        [true] = {
            [rd.front] = rd.front,
            [rd.back] = rd.back
        },
        [false] = {
            [rd.front] = rd.back,
            [rd.back] = rd.front
        }
    },

    opposite_signal_offsets = {
        [dir.north] = {x=3, y=0, d=dir.south},
        [dir.northeast] = {x=2.5, y=2.5, d=dir.southwest},
    },

    connected_rail_permutations = {},
    all_connected_rail_permutations = {},

    --[[
    rail_data format:
        [entity.name] = {
            [entity.direction] = {
                signals = {
                    [rail_direction] = {
                        {x=xoffset, y=yoffset, d=direction},s
                        ...
                    }
                },
                length = 1,
                cardinality = false,
            },
        }


    Signals:
        Signals are listed in direction of travel.  So, a train travelling along this track's "front" direction will
        encounters signals in the order they appear in in that list.

        Offsets are where the signals are located relative to the track.

    Chirality:
        Different rail segments have different notions of where their 'front' is.
        While following a circular section of track clockwise, two adjacent sections of track have the same chirality
        If their fronts face the same direction -- that is, neither front points at the other track segment.
    ]]

    rail_data = {
        ["straight-rail"] = {
            [dir.north] = {
                length = 2,
                signals = {
                    [rd.front] = {
                        {x=1.5, y= 0.5, d=dir.south, stops=-1, starts=1},  -- Train stops 1 unit before this rail begins
                        {x=1.5, y=-0.5, d=dir.south, stops=1, starts=2},
                    },
                    [rd.back] = {
                        {x=-1.5, y=-0.5, d=dir.north, stops=-1, starts=1},
                        {x=-1.5, y= 0.5, d=dir.north, stops=1, starts=2},
                    },
                },
                chirality = false,
            },
            [dir.northeast] = {
                length = sqrt2,
                signals = {
                    [rd.front] = {{x=1.5, y=-1.5, d=dir.southeast, stops=-1, starts=1}},
                    [rd.back] = {{x=-0.5, y=0.5, d=dir.northwest, stops=0, starts=1}},
                },
                chirality = false,
            }
        },
        ["curved-rail"] = {
            [dir.north] = {
                length = 8,
                signals = {
                    [rd.front] = {
                        {x=-2.5, y=-1.5, d=dir.northwest, stops=-1, starts=1},
                        {x=-0.5, y=3.5, d=dir.north, stops=7, starts=8}
                    },
                    [rd.back] = {
                        {x=2.5, y=3.5, d=dir.south, stops=-1, starts=1},
                        {x=-0.5, y=-3.5, d=dir.southeast, stops=7, starts=8}
                    },
                },
                chirality = false,
            },
            [dir.northeast] = {
                length = 8,
                signals = {
                    [rd.front] = {
                        {x=0.5, y=-3.5, d=dir.northeast, stops=-1, starts=1},
                        {x=-2.5, y=3.5, d=dir.north, stops=7, starts=8},
                    },
                    [rd.back] = {
                        {x=0.5, y=3.5, d=dir.south, stops=-1, starts=1},
                        {x=2.5, y=-1.5, d=dir.southwest, stops=7, starts=8},
                    },
                },
                chirality = false,
            }
        }
    },
    
    signal_data = {}, -- To be filled later.
}
librail.opposite_direction = librail.chiral_directions[false]


for _, rail_direction in pairs(librail.rail_directions) do
    librail.connected_rail_permutations[rail_direction] = {}
    for _, rail_connection_direction in pairs(librail.rail_connection_directions) do
        local t = {rail_direction=rail_direction, rail_connection_direction=rail_connection_direction }
        table.insert(librail.connected_rail_permutations[rail_direction], t)
        table.insert(librail.all_connected_rail_permutations, t)
    end
end


-- Generate a reasonably unique key based on offset x/y/d.  Assumes offsets will never be bigger than +/- 10 or so.
function librail.offset_to_key(offset)
    -- Offsets are no bigger than 10.  Generate a reasonable key based on them for fast lookups.
    -- They're also always directional...
    return librail.args_to_key(offset.x, offset.y, offset.d)
end


function librail.args_to_key(x, y, d)
    -- log("x=" .. x .. "; y=" .. y .. "; d=" .. d .. "; k=" .. x*1000000 + y*1000 + d)
    return x*1000000 + y*1000 + d
end


function librail.get_rail_data(entity)
    return librail.rail_data[entity.type] and librail.rail_data[entity.type][entity.direction] or nil
end


-- Add rotations for other opposite signals.
for source, dest in each_rotation() do
    librail.opposite_signal_offsets[dest] = rotate_cw(librail.opposite_signal_offsets[source])
end


-- Finish up rail data and generate signal data.
do
    local t

    for entity_type, entity_data in pairs(librail.rail_data) do
        -- Add rotations for directions other than north and northeast.
        -- This could be simplified, but this reads better.  And it's not a performance critical segment of code.
        for source, dest in each_rotation() do
            t = {
                length = entity_data[source].length,
                chirality = entity_data[source].chirality,
                signals = {}
            }

            for dir, signals in pairs(entity_data[source].signals) do
                t.signals[dir] = {}
                for i = 1, #signals do
                    t.signals[dir][i] = rotate_cw(signals[i])
                    t.signals[dir][i].stops = signals[i].stops
                    t.signals[dir][i].starts = signals[i].starts
                end
            end
            entity_data[dest] = t
        end


        -- Second pass: Create the signal map and determine signal search areas.
        for entity_direction, direction_data in pairs(entity_data) do
            direction_data.signal_map = {}
            for rail_direction, signals in pairs(direction_data.signals) do
                log("Rail direction: " .. rail_direction)
                for i=1, #signals do
                    local offset = signals[i]

                    -- Update bounds for direction search.
                    direction_data.bounds = expand_bounds(direction_data.bounds, offset)

                    -- Generate a map of where our signals are
                    direction_data.signal_map[librail.offset_to_key(offset)] = {
                        rail_direction = rail_direction, x = offset.x, y = offset.y, seq = i, d = offset.d,
                        stops=offset.stops, starts=offset.starts
                    }

                    -- Do the same thing in reverse for signals.
                    local signal = librail.signal_data[offset.d]
                    if not signal then
                        signal = { rail_map = {} }
                        librail.signal_data[offset.d] = signal
                    end
                    signal.bounds = expand_bounds(signal.bounds, {x=-offset.x, y=-offset.y})

                    if not signal.rail_map[entity_type] then
                        signal.rail_map[entity_type] = {}
                    end

                    local k = librail.args_to_key(-offset.x, -offset.y, entity_direction)
                    signal.rail_map[entity_type][k] = {
                        direction = entity_direction,
                        rail_direction = rail_direction, signal_index = i, signal = offset, rail_data = direction_data,
                        x = -offset.x, y = -offset.y, d = entity_direction,
                    }
                end
            end
        end
    end
end


--
-- Library functions
--

-- Find rail(s) that this signal might belong to.
function librail.find_rail_for_signal(signal)
    local rails = {}
    local ent
    local data = librail.signal_data[signal.direction]
    local ents = signal.surface.find_entities_filtered{
        area=offset_bounds(data.bounds, signal.position),
        type=librail.rail_entity_types
    }
    local temp
    local k

    for i = 1, #ents do
        ent = ents[i]
        k = librail.args_to_key(ent.position.x - signal.position.x, ent.position.y - signal.position.y, ent.direction)
        temp = data.rail_map[ent.type][k]
        if temp then
            table.insert(rails, {
                entity=ent, direction=temp.d, rail_direction=temp.rail_direction,
                signal_index = temp.signal_index, signal = temp.signal,
                rail_data=temp.rail_data,
            })
        end
    end
    return rails
end


function librail.sort_signals(a, b)
    return a.rail_direction < b.rail_direction or (a.rail_direction == b.rail_direction and a.seq < b.seq)
end


-- Find signals that belong to this rail.  NOTE: Signals may belong to more than one rail.
function librail.find_signals(rail, rail_direction, sort, data)
    data = data or librail.get_rail_data(rail)
    if not data then return end
    local ent
    local signals = {}
    local ents = rail.surface.find_entities_filtered{
        area=offset_bounds(data.bounds, rail.position),
        type=librail.signal_entity_types
    }
    local k
    local x, y = rail.position.x, rail.position.y
    local temp
    --log(serpent.block(data.signal_map))

    for i = 1, #ents do
        ent = ents[i]
        k = librail.args_to_key(ent.position.x - x, ent.position.y - y, ent.direction)
        log("k=" .. k)
        temp = data.signal_map[k]
        if temp and (not rail_direction or rail_direction == temp.rail_direction) then
            table.insert(signals, {entity=ent, rail=rail, rail_direction=temp.rail_direction, starts=temp.starts, stops=temp.stops, seq=temp.seq})
        end
    end

    if sort then
        table.sort(signals, librail.sort_signals)
    end
    return signals
end


-- Iterate over connected rails in one or both directions
function librail.each_connected_rail(entity, direction)
    local t = direction and librail.connected_rail_permutations[direction] or librail.all_connected_rail_permutations
    --log(serpent.block(t))
    local i, n = 0, #t
    local connected
    local function iterator()
        while i < n do
            i = i + 1
            connected = entity.get_connected_rail(t[i])
            if connected then
                log("Connected rail: " .. entity.unit_number .. "->" .. connected.unit_number .. " (" .. serpent.line(t[i]) .. ")")
                return connected, t[i]
            end
        end
    end
    return iterator
end


-- Iterate over conecting rails until reaching the end of the tracks -- or a branch.
function librail.walk_to_branch(rail, rail_direction)
    local length = 0
    local next = rail
    local temp
    local first_unit_number = rail.unit_number
    local function iterator()
        if not next then
            return
        end
        rail, next, temp = next, nil, nil
        length = length + librail.rail_data[rail.type][rail.direction].length
        for temp in librail.each_connected_rail(rail, rail_direction) do
            if next then    -- More than one connected rail.
                next = nil
                return rail, rail_direction, length
            else
                next = temp
            end
        end

        temp = rail_direction
        if next then
            if next.unit_number == first_unit_number then
                next = nil
            else
                rail_direction = librail.chiral_directions[
                    librail.rail_data[rail.type][rail.direction].chirality == librail.rail_data[next.type][next.direction].chirality
                ][rail_direction]
            end
        end
        return rail, temp, length

    end
    return iterator
end


-- walk_to_branch, but also terminates on entering branches and crossings.
function librail.walk_to_crossing(rail, rail_direction)
    local real_iterator = librail.walk_to_branch(rail, rail_direction)
    local rail, dir, length, prev, revdir, temp
    local args = {type=librail.rail_entity_types}
    local function iterator()
        rail, dir, length = real_iterator()
        if not rail then
            -- Ran out of rail, or there was a forward branch
            return
        elseif prev then
            for temp in librail.each_connected_rail(rail, librail.opposite_direction[dir]) do
                if temp ~= prev then return end    -- Reverse branch.
            end
        end
        args.area=rail.bounding_box
        if rail.surface.count_entities_filtered(args) > 1 then return end
        if rail.secondary_bounding_box then
            args.area=rail.secondary_bounding_box
            if rail.surface.count_entities_filtered(args) > 1 then return end
        end
        return rail, dir, length
    end
    return iterator
end


-- Returns the opposite rail signal (for bidirectional rail), or nil if their is no such signal
function librail.opposite_signal(entity)
    local offset = librail.opposite_signal_offsets[entity.direction]
    local position = {entity.x + offset.x, entity.y + offset.y}
    local ents = entity.surface.find_entities_filtered{position=position, type=librail.signal_entity_types }
    local ent
    for i = 1, #ents do
        ent = ents[i]
        if ent.position.x == position.x and ent.position.y == position.y and ent.direction == offset.d then
            return ent
        end
    end
end





return librail
